name: Deploy MCP Server to AWS Lambda

on:
  workflow_dispatch:

env:
  AWS_REGION: eu-central-1
  FUNCTION_NAME: daap-mcp-server
  LAMBDA_ARCHITECTURE: x86_64  # Change to arm64 if you want ARM64 Lambda
  API_GATEWAY_NAME: daap-mcp-server-api
  
  # IAM Resources
  ROLE_NAME: daap-mcp-server-role
  API_POLICY_NAME: daap-mcp-server-api-policy
  S3_POLICY_NAME: daap-mcp-server-s3-policy
  
  # S3 Configuration
  S3_BUCKET_NAME: databricks-dev-external-ext-str-raw-data-eu-central-1
  
  # API Gateway Configuration
  API_STAGE_NAME: dev
  MCP_ENDPOINT_PATH: /mcp
  MCP_ENDPOINT_PATH_PART: mcp
  HEALTH_ENDPOINT_PATH: /health
  HTTP_METHOD: POST
  AUTHORIZATION_TYPE: AWS_IAM
  INTEGRATION_TYPE: AWS_PROXY
  
  # Lambda Configuration
  RUNTIME: python3.12
  MEMORY_SIZE: 1024
  TIMEOUT: 120
  HANDLER: lambda_handler.lambda_handler

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install uv
        uses: astral-sh/setup-uv@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create Lambda layers
        run: |
          # Ensure Python 3.12 is used for layer creation
          python --version
          chmod +x scripts/create_lambda_layers.sh
          ./scripts/create_lambda_layers.sh

      - name: Get AWS account ID
        run: |
          # Get AWS account ID once and store it for reuse
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
          echo "âœ… AWS Account ID: $ACCOUNT_ID"

      - name: Upload Lambda layers to AWS
        run: |
          # Upload Core layer
          if [ -f "lambda-layers/daap-mcp-server-fastmcp-urllib3.zip" ]; then
            echo "Uploading Core layer..."
            CORE_LAYER_ARN=$(aws lambda publish-layer-version \
              --layer-name daap-mcp-server-fastmcp-urllib3 \
              --description "Core MCP dependencies (fastmcp==2.12.4, urllib3==2.5.0)" \
              --zip-file fileb://lambda-layers/daap-mcp-server-fastmcp-urllib3.zip \
              --compatible-runtimes python3.12 \
              --compatible-architectures ${{ env.LAMBDA_ARCHITECTURE }} \
              --query 'LayerVersionArn' \
              --output text)
            echo "CORE_LAYER_ARN=$CORE_LAYER_ARN" >> $GITHUB_ENV
            echo "âœ… Core layer uploaded: $CORE_LAYER_ARN"
          else
            echo "âŒ Core layer not found!"
            exit 1
          fi
          
          # Upload Data layer
          if [ -f "lambda-layers/daap-mcp-server-pandas.zip" ]; then
            echo "Uploading Data layer..."
            DATA_LAYER_ARN=$(aws lambda publish-layer-version \
              --layer-name daap-mcp-server-pandas \
              --description "Data processing dependencies (pandas==2.3.2)" \
              --zip-file fileb://lambda-layers/daap-mcp-server-pandas.zip \
              --compatible-runtimes python3.12 \
              --compatible-architectures ${{ env.LAMBDA_ARCHITECTURE }} \
              --query 'LayerVersionArn' \
              --output text)
            echo "DATA_LAYER_ARN=$DATA_LAYER_ARN" >> $GITHUB_ENV
            echo "âœ… Data layer uploaded: $DATA_LAYER_ARN"
          else
            echo "âš ï¸  Data layer not found, skipping..."
            echo "DATA_LAYER_ARN=" >> $GITHUB_ENV
          fi
          
          # Combine layer ARNs (boto3 is pre-installed in Lambda)
          if [ -n "$DATA_LAYER_ARN" ]; then
            LAYER_ARNS="$CORE_LAYER_ARN $DATA_LAYER_ARN"
          else
            LAYER_ARNS="$CORE_LAYER_ARN"
          fi
          echo "LAYER_ARNS=$LAYER_ARNS" >> $GITHUB_ENV
          echo "â„¹ï¸ Note: boto3 is pre-installed in AWS Lambda, so no layer needed"
          
          # Get layer sizes for reporting
          echo "ðŸ“Š Package sizes:"
          ls -lh lambda-layers/*.zip | grep -E "(daap-mcp-server|mcp-lambda-function)" || echo "No layer files found"

      - name: Create minimal deployment package
        run: |
          # Use the minimal package created by layers script
          cp mcp-lambda-function.zip mcp-server-deployment.zip
          echo "âœ… Using minimal deployment package with layers"

      - name: Setup IAM and Lambda
        run: |
          # Use AWS account ID from previous step
          echo "Using AWS Account ID: $ACCOUNT_ID"
          
          # Check if function exists
          if aws lambda get-function --function-name ${{ env.FUNCTION_NAME }} >/dev/null 2>&1; then
            echo "ðŸ”„ Updating existing Lambda function..."
            aws lambda update-function-code \
              --function-name ${{ env.FUNCTION_NAME }} \
              --zip-file fileb://mcp-server-deployment.zip
            echo "âœ… Lambda function code updated successfully"
            
            # Update layers with retry logic
            echo "Updating Lambda function layers..."
            for i in {1..3}; do
              if aws lambda update-function-configuration \
                --function-name ${{ env.FUNCTION_NAME }} \
                --layers $LAYER_ARNS; then
                echo "âœ… Lambda function layers updated successfully"
                break
              else
                echo "âš ï¸  Attempt $i failed, waiting 10 seconds before retry..."
                sleep 10
              fi
            done
          else
            echo "ðŸ†• Creating new Lambda function..."
            
            # Create IAM role (ignore if already exists)
            echo "Creating IAM role: ${{ env.ROLE_NAME }}"
            aws iam create-role \
              --role-name ${{ env.ROLE_NAME }} \
              --assume-role-policy-document '{
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Principal": {
                      "Service": "lambda.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                  }
                ]
              }' 2>/dev/null && echo "âœ… IAM role created successfully" || echo "â„¹ï¸  IAM role already exists, continuing..."
            
            # Attach basic execution policy
            echo "Attaching basic execution policy..."
            if aws iam attach-role-policy \
              --role-name ${{ env.ROLE_NAME }} \
              --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole; then
              echo "âœ… Basic execution policy attached successfully"
            else
              echo "â„¹ï¸  Basic execution policy may already be attached"
            fi
            
            # Create and attach S3 policy
            echo "Creating S3 policy..."
            S3_POLICY_ARN=$(aws iam create-policy \
              --policy-name ${{ env.S3_POLICY_NAME }} \
              --policy-document '{
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Action": ["s3:GetObject", "s3:ListBucket"],
                    "Resource": [
                      "arn:aws:s3:::${{ env.S3_BUCKET_NAME }}",
                      "arn:aws:s3:::${{ env.S3_BUCKET_NAME }}/*"
                    ]
                  }
                ]
              }' \
              --query 'Policy.Arn' \
              --output text 2>/dev/null)
            
            # If S3 policy creation failed, get existing policy ARN
            if [ -z "$S3_POLICY_ARN" ]; then
              echo "S3 policy already exists, getting existing policy ARN..."
              S3_POLICY_ARN=$(aws iam get-policy --policy-arn "arn:aws:iam::$ACCOUNT_ID:policy/${{ env.S3_POLICY_NAME }}" --query 'Policy.Arn' --output text 2>/dev/null)
              if [ ! -z "$S3_POLICY_ARN" ]; then
                echo "âœ… Found existing S3 policy: $S3_POLICY_ARN"
              else
                echo "âŒ Failed to create or find S3 policy"
                exit 1
              fi
            else
              echo "âœ… Created new S3 policy: $S3_POLICY_ARN"
            fi
            
            # Attach S3 policy if we have a valid ARN
            if [ ! -z "$S3_POLICY_ARN" ]; then
              echo "Attaching S3 policy to role..."
              if aws iam attach-role-policy \
                --role-name ${{ env.ROLE_NAME }} \
                --policy-arn $S3_POLICY_ARN; then
                echo "âœ… S3 policy attached successfully"
              else
                echo "â„¹ï¸  S3 policy may already be attached"
              fi
            else
              echo "âŒ No valid S3 policy ARN to attach"
              exit 1
            fi
            
            # Wait for role to be ready
            echo "Waiting for IAM role to be ready..."
            sleep 10
            
            # Verify the deployment package exists and is valid
            echo "Verifying deployment package..."
            if [ ! -f "mcp-server-deployment.zip" ]; then
              echo "âŒ Deployment package not found!"
              exit 1
            fi
            
            # Check if the zip file is valid
            if ! unzip -t mcp-server-deployment.zip >/dev/null 2>&1; then
              echo "âŒ Deployment package is corrupted!"
              exit 1
            fi
            echo "âœ… Deployment package is valid"
            
            # Verify IAM role has the necessary permissions
            echo "Verifying IAM role permissions..."
            aws iam list-attached-role-policies --role-name ${{ env.ROLE_NAME }} --output table
            
            # Check if Lambda function exists in any state
            echo "Checking for existing Lambda function..."
            if aws lambda get-function --function-name ${{ env.FUNCTION_NAME }} >/dev/null 2>&1; then
              echo "â„¹ï¸  Lambda function already exists, getting details..."
              aws lambda get-function --function-name ${{ env.FUNCTION_NAME }} --query 'Configuration.{FunctionName:FunctionName,State:State,LastUpdateStatus:LastUpdateStatus}' --output table
              
              # If function exists, update it instead of creating
              echo "Updating existing Lambda function..."
              if aws lambda update-function-code \
                --function-name ${{ env.FUNCTION_NAME }} \
                --zip-file fileb://mcp-server-deployment.zip; then
                echo "âœ… Lambda function code updated successfully"
                
                # Update layers
                echo "Updating Lambda function layers..."
                aws lambda update-function-configuration \
                  --function-name ${{ env.FUNCTION_NAME }} \
                  --layers $LAYER_ARNS
                echo "âœ… Lambda function layers updated successfully"
                exit 0
              else
                echo "âŒ Failed to update Lambda function"
                exit 1
              fi
            fi
            
            # Get role ARN and create Lambda function
            echo "Getting IAM role ARN..."
            ROLE_ARN=$(aws iam get-role --role-name ${{ env.ROLE_NAME }} --query 'Role.Arn' --output text)
            if [ -z "$ROLE_ARN" ]; then
              echo "âŒ Failed to get IAM role ARN"
              exit 1
            fi
            echo "âœ… IAM Role ARN: $ROLE_ARN"
            
            echo "Creating Lambda function: ${{ env.FUNCTION_NAME }}"
            echo "Using role ARN: $ROLE_ARN"
            echo "Deployment package size: $(ls -lh mcp-server-deployment.zip | awk '{print $5}')"
            
            # Try to create the Lambda function with layers
            if aws lambda create-function \
              --function-name ${{ env.FUNCTION_NAME }} \
              --runtime ${{ env.RUNTIME }} \
              --role $ROLE_ARN \
              --handler ${{ env.HANDLER }} \
              --zip-file fileb://mcp-server-deployment.zip \
              --layers $LAYER_ARNS \
              --architecture ${{ env.LAMBDA_ARCHITECTURE }} \
              --memory-size ${{ env.MEMORY_SIZE }} \
              --timeout ${{ env.TIMEOUT }} 2>&1; then
              echo "âœ… Lambda function created successfully"
            else
              echo "âŒ Lambda function creation failed, checking if it exists..."
              
              # Check if function exists with more detailed output
              if aws lambda get-function --function-name ${{ env.FUNCTION_NAME }} 2>&1; then
                echo "ðŸ”„ Lambda function exists, updating code..."
                if aws lambda update-function-code \
                  --function-name ${{ env.FUNCTION_NAME }} \
                  --zip-file fileb://mcp-server-deployment.zip 2>&1; then
                  echo "âœ… Lambda function code updated successfully"
                  
                  # Update layers
                  echo "Updating Lambda function layers..."
                  aws lambda update-function-configuration \
                    --function-name ${{ env.FUNCTION_NAME }} \
                    --layers $LAYER_ARNS
                  echo "âœ… Lambda function layers updated successfully"
                else
                  echo "âŒ Failed to update Lambda function"
                  exit 1
                fi
              else
                echo "âŒ Lambda function creation failed and function doesn't exist"
                echo "Checking AWS CLI error details..."
                aws lambda create-function \
                  --function-name ${{ env.FUNCTION_NAME }} \
                  --runtime ${{ env.RUNTIME }} \
                  --role $ROLE_ARN \
                  --handler ${{ env.HANDLER }} \
                  --zip-file fileb://mcp-server-deployment.zip \
                  --architecture ${{ env.LAMBDA_ARCHITECTURE }} \
                  --memory-size ${{ env.MEMORY_SIZE }} \
                  --timeout ${{ env.TIMEOUT }} || true
                exit 1
              fi
            fi
          fi

      - name: Wait for Lambda to be ready
        run: |
          echo "Waiting for Lambda function to be ready..."
          for i in {1..30}; do
            STATE=$(aws lambda get-function --function-name ${{ env.FUNCTION_NAME }} --query 'Configuration.State' --output text 2>/dev/null || echo "Unknown")
            echo "Attempt $i: Function state is $STATE"
            if [ "$STATE" = "Active" ]; then
              echo "Function is ready!"
              break
            elif [ "$STATE" = "Failed" ]; then
              echo "Function creation failed!"
              exit 1
            fi
            sleep 10
          done
          
          if [ "$STATE" != "Active" ]; then
            echo "Function did not become active within 5 minutes"
            exit 1
          fi

      - name: Test Lambda function
        run: |
          # Create test payload
          cat > test-payload.json << 'EOF'
          {
            "version": "2.0",
            "routeKey": "POST /mcp",
            "rawPath": "/mcp",
            "rawQueryString": "",
            "headers": {
              "content-type": "application/json",
              "host": "localhost"
            },
            "requestContext": {
              "http": {
                "method": "POST",
                "path": "/mcp",
                "protocol": "HTTP/1.1",
                "sourceIp": "127.0.0.1",
                "userAgent": "test-agent"
              },
              "requestId": "test-request-id",
              "accountId": "123456789012",
              "apiId": "test-api-id",
              "stage": "test"
            },
            "body": "{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\", \"params\": {}}",
            "isBase64Encoded": false
          }
          EOF
          
          # Test with retry logic
          echo "Testing Lambda function..."
          for i in {1..5}; do
            echo "Test attempt $i..."
            if aws lambda invoke \
              --function-name ${{ env.FUNCTION_NAME }} \
              --payload fileb://test-payload.json \
              response.json; then
              echo "MCP Function response:"
              cat response.json
              break
            else
              echo "Test failed, retrying in 10 seconds..."
              sleep 10
            fi
          done
          
          # Clean up
          rm -f test-payload.json response.json

      - name: Get Lambda ARN
        run: |
          # Get Lambda ARN once and store it for reuse
          LAMBDA_ARN=$(aws lambda get-function --function-name ${{ env.FUNCTION_NAME }} --query 'Configuration.FunctionArn' --output text)
          echo "LAMBDA_ARN=$LAMBDA_ARN" >> $GITHUB_ENV
          echo "âœ… Lambda ARN: $LAMBDA_ARN"

      - name: Setup API Gateway
        run: |
          # Use AWS account ID and Lambda ARN from previous steps
          echo "Using AWS Account ID: $ACCOUNT_ID"
          echo "Using Lambda ARN: $LAMBDA_ARN"
          
          # Check if API Gateway already exists and store ID
          echo "Looking for existing API Gateway: ${{ env.API_GATEWAY_NAME }}"
          API_ID=$(aws apigateway get-rest-apis --query "items[?name=='${{ env.API_GATEWAY_NAME }}'].id" --output text | head -1)
          echo "API_ID=$API_ID" >> $GITHUB_ENV
          echo "Found API Gateway ID: $API_ID"
          
          if [ -z "$API_ID" ]; then
            echo "No existing API Gateway found, will create new one"
          else
            echo "Found existing API Gateway with ID: $API_ID"
          fi
          
          if [ -z "$API_ID" ]; then
            echo "Creating new API Gateway..."
            API_ID=$(aws apigateway create-rest-api --name ${{ env.API_GATEWAY_NAME }} --query 'id' --output text)
            
            if [ -z "$API_ID" ]; then
              echo "âŒ Failed to create API Gateway"
              exit 1
            fi
            
            echo "Created API Gateway with ID: $API_ID"
            ROOT_ID=$(aws apigateway get-resources --rest-api-id $API_ID --query 'items[0].id' --output text)
            
            # Create endpoints
            MCP_ID=$(aws apigateway create-resource --rest-api-id $API_ID --parent-id $ROOT_ID --path-part ${{ env.MCP_ENDPOINT_PATH_PART }} --query 'id' --output text)
            HEALTH_ID=$(aws apigateway create-resource --rest-api-id $API_ID --parent-id $ROOT_ID --path-part health --query 'id' --output text)
            
            # Configure methods
            aws apigateway put-method --rest-api-id $API_ID --resource-id $MCP_ID --http-method ${{ env.HTTP_METHOD }} --authorization-type ${{ env.AUTHORIZATION_TYPE }}
            aws apigateway put-method --rest-api-id $API_ID --resource-id $HEALTH_ID --http-method GET --authorization-type ${{ env.AUTHORIZATION_TYPE }}
            
            # Configure integrations
            aws apigateway put-integration --rest-api-id $API_ID --resource-id $MCP_ID --http-method ${{ env.HTTP_METHOD }} --type ${{ env.INTEGRATION_TYPE }} --integration-http-method ${{ env.HTTP_METHOD }} --uri "arn:aws:apigateway:${{ env.AWS_REGION }}:lambda:path/2015-03-31/functions/$LAMBDA_ARN/invocations"
            aws apigateway put-integration --rest-api-id $API_ID --resource-id $HEALTH_ID --http-method GET --type ${{ env.INTEGRATION_TYPE }} --integration-http-method ${{ env.HTTP_METHOD }} --uri "arn:aws:apigateway:${{ env.AWS_REGION }}:lambda:path/2015-03-31/functions/$LAMBDA_ARN/invocations"
            
            # Deploy API Gateway
            aws apigateway create-deployment --rest-api-id $API_ID --stage-name ${{ env.API_STAGE_NAME }}
            
            # Add Lambda permissions
            MCP_STATEMENT_ID="apigateway-invoke-$(date +%s)"
            HEALTH_STATEMENT_ID="apigateway-invoke-health-$(date +%s)"
            
            aws lambda add-permission \
              --function-name ${{ env.FUNCTION_NAME }} \
              --statement-id $MCP_STATEMENT_ID \
              --action lambda:InvokeFunction \
              --principal apigateway.amazonaws.com \
              --source-arn "arn:aws:execute-api:${{ env.AWS_REGION }}:$ACCOUNT_ID:$API_ID/*/${{ env.HTTP_METHOD }}${{ env.MCP_ENDPOINT_PATH }}" || echo "MCP permission may already exist"
            
            aws lambda add-permission \
              --function-name ${{ env.FUNCTION_NAME }} \
              --statement-id $HEALTH_STATEMENT_ID \
              --action lambda:InvokeFunction \
              --principal apigateway.amazonaws.com \
              --source-arn "arn:aws:execute-api:${{ env.AWS_REGION }}:$ACCOUNT_ID:$API_ID/*/GET${{ env.HEALTH_ENDPOINT_PATH }}" || echo "Health permission may already exist"
            
            # Create and attach API Gateway IAM policy
            POLICY_ARN=$(aws iam create-policy \
              --policy-name ${{ env.API_POLICY_NAME }} \
              --policy-document '{
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Action": "execute-api:Invoke",
                    "Resource": [
                      "arn:aws:execute-api:'${{ env.AWS_REGION }}':*:'$API_ID'/*/${{ env.HTTP_METHOD }}${{ env.MCP_ENDPOINT_PATH }}",
                      "arn:aws:execute-api:'${{ env.AWS_REGION }}':*:'$API_ID'/*/GET${{ env.HEALTH_ENDPOINT_PATH }}"
                    ]
                  }
                ]
              }' \
              --query 'Policy.Arn' \
              --output text 2>/dev/null)
            
            if [ -z "$POLICY_ARN" ]; then
              echo "Policy already exists, getting existing policy ARN..."
              POLICY_ARN=$(aws iam get-policy --policy-arn "arn:aws:iam::$ACCOUNT_ID:policy/${{ env.API_POLICY_NAME }}" --query 'Policy.Arn' --output text 2>/dev/null)
            fi
            
            if [ ! -z "$POLICY_ARN" ]; then
              aws iam attach-role-policy \
                --role-name ${{ env.ROLE_NAME }} \
                --policy-arn $POLICY_ARN || echo "Policy may already be attached"
            else
              echo "Warning: Could not create or find policy ARN"
            fi
            
            # Store API Gateway info
            echo "API_GATEWAY_ID=$API_ID" >> $GITHUB_ENV
            echo "API_ID=$API_ID" >> $GITHUB_ENV
            echo "API_GATEWAY_URL=https://$API_ID.execute-api.${{ env.AWS_REGION }}.amazonaws.com/${{ env.API_STAGE_NAME }}" >> $GITHUB_ENV
          else
            echo "Using existing API Gateway: $API_ID"
            
            # Update MCP endpoint
            MCP_ID=$(aws apigateway get-resources --rest-api-id $API_ID --query "items[?pathPart=='${{ env.MCP_ENDPOINT_PATH_PART }}'].id" --output text | head -1)
            if [ ! -z "$MCP_ID" ]; then
              aws apigateway put-integration --rest-api-id $API_ID --resource-id $MCP_ID --http-method ${{ env.HTTP_METHOD }} --type ${{ env.INTEGRATION_TYPE }} --integration-http-method ${{ env.HTTP_METHOD }} --uri "arn:aws:apigateway:${{ env.AWS_REGION }}:lambda:path/2015-03-31/functions/$LAMBDA_ARN/invocations"
              # Update method authorization
              aws apigateway update-method --rest-api-id $API_ID --resource-id $MCP_ID --http-method ${{ env.HTTP_METHOD }} --patch-operations '[{"op":"replace","path":"/authorizationType","value":"'${{ env.AUTHORIZATION_TYPE }}'"}]' || echo "Method update failed, continuing..."
            fi
            
            # Update health endpoint
            HEALTH_ID=$(aws apigateway get-resources --rest-api-id $API_ID --query "items[?pathPart=='health'].id" --output text | head -1)
            ROOT_ID=$(aws apigateway get-resources --rest-api-id $API_ID --query 'items[0].id' --output text)
            
            if [ -z "$HEALTH_ID" ]; then
              echo "Creating missing /health endpoint..."
              HEALTH_ID=$(aws apigateway create-resource --rest-api-id $API_ID --parent-id $ROOT_ID --path-part health --query 'id' --output text)
              aws apigateway put-method --rest-api-id $API_ID --resource-id $HEALTH_ID --http-method GET --authorization-type ${{ env.AUTHORIZATION_TYPE }}
            else
              # Update existing health endpoint to use IAM auth
              aws apigateway update-method --rest-api-id $API_ID --resource-id $HEALTH_ID --http-method GET --patch-operations '[{"op":"replace","path":"/authorizationType","value":"'${{ env.AUTHORIZATION_TYPE }}'"}]' || echo "Health method update failed, continuing..."
            fi
            
            aws apigateway put-integration --rest-api-id $API_ID --resource-id $HEALTH_ID --http-method GET --type ${{ env.INTEGRATION_TYPE }} --integration-http-method ${{ env.HTTP_METHOD }} --uri "arn:aws:apigateway:${{ env.AWS_REGION }}:lambda:path/2015-03-31/functions/$LAMBDA_ARN/invocations"
            
            # Ensure health endpoint has Lambda permission
            HEALTH_STATEMENT_ID="apigateway-invoke-health-$(date +%s)"
            aws lambda add-permission \
              --function-name ${{ env.FUNCTION_NAME }} \
              --statement-id $HEALTH_STATEMENT_ID \
              --action lambda:InvokeFunction \
              --principal apigateway.amazonaws.com \
              --source-arn "arn:aws:execute-api:${{ env.AWS_REGION }}:$ACCOUNT_ID:$API_ID/*/GET${{ env.HEALTH_ENDPOINT_PATH }}" || echo "Health permission may already exist"
            
            # Redeploy API Gateway
            aws apigateway create-deployment --rest-api-id $API_ID --stage-name ${{ env.API_STAGE_NAME }}
            
            # Store API Gateway info for existing API
            echo "API_GATEWAY_ID=$API_ID" >> $GITHUB_ENV
            echo "API_ID=$API_ID" >> $GITHUB_ENV
            echo "API_GATEWAY_URL=https://$API_ID.execute-api.${{ env.AWS_REGION }}.amazonaws.com/${{ env.API_STAGE_NAME }}" >> $GITHUB_ENV
          fi
          
          # Wait for deployment to complete
          sleep 3
          
          # Output endpoint URLs
          API_URL="https://$API_ID.execute-api.${{ env.AWS_REGION }}.amazonaws.com/${{ env.API_STAGE_NAME }}"
          echo "MCP Endpoint: $API_URL${{ env.MCP_ENDPOINT_PATH }}"
          echo "Health Check: $API_URL${{ env.HEALTH_ENDPOINT_PATH }}"

      - name: Wait for API Gateway deployment
        run: |
          echo "Waiting for API Gateway deployment to complete..."
          sleep 30

      - name: Test API Gateway
        run: |
          # Use API Gateway ID from previous step
          echo "Using API Gateway ID: ${{ env.API_ID }}"
          API_URL="https://${{ env.API_ID }}.execute-api.${{ env.AWS_REGION }}.amazonaws.com/${{ env.API_STAGE_NAME }}"

          echo "API Gateway URL: $API_URL"
          echo "MCP Endpoint: $API_URL${{ env.MCP_ENDPOINT_PATH }}"
          echo "Health Check: $API_URL${{ env.HEALTH_ENDPOINT_PATH }}"

          # Test health endpoint with IAM authentication
          echo "Testing health endpoint with IAM authentication..."
          echo "Looking for health resource in API Gateway: ${{ env.API_ID }}"
          HEALTH_ID=$(aws apigateway get-resources --rest-api-id ${{ env.API_ID }} --query "items[?pathPart=='health'].id" --output text | head -1)
          echo "Found health resource ID: $HEALTH_ID"
          
          if [ -z "$HEALTH_ID" ]; then
            echo "âŒ Health resource not found in API Gateway"
            echo "Available resources:"
            aws apigateway get-resources --rest-api-id ${{ env.API_ID }} --query 'items[*].{pathPart:pathPart,id:id}' --output table
            exit 1
          fi
          
          # Test using AWS CLI with IAM authentication
          for i in {1..3}; do
            echo "Health test attempt $i..."
            if aws apigateway test-invoke-method \
              --rest-api-id ${{ env.API_ID }} \
              --resource-id $HEALTH_ID \
              --http-method GET \
              --headers 'Content-Type=application/json' > health-response.json; then
              echo "Health test passed!"
              cat health-response.json
              break
            else
              echo "Health test attempt $i failed, retrying..."
              sleep 10
            fi
          done

          # Test MCP endpoint
          echo "Testing MCP endpoint with IAM authentication..."
          MCP_ID=$(aws apigateway get-resources --rest-api-id ${{ env.API_ID }} --query "items[?pathPart=='${{ env.MCP_ENDPOINT_PATH_PART }}'].id" --output text | head -1)
          
          if [ -z "$MCP_ID" ]; then
            echo "âŒ MCP resource not found in API Gateway"
            exit 1
          fi
          
          echo "Found MCP resource ID: $MCP_ID"
          
          # Create test payload
          cat > test-mcp-payload.json << 'EOF'
          {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "tools/list",
            "params": {}
          }
          EOF
          
          # Test using AWS CLI with IAM authentication
          for i in {1..3}; do
            echo "Test attempt $i..."
            if aws apigateway test-invoke-method \
              --rest-api-id ${{ env.API_ID }} \
              --resource-id $MCP_ID \
              --http-method ${{ env.HTTP_METHOD }} \
              --body file://test-mcp-payload.json \
              --headers 'Content-Type=application/json' > test-response.json; then
              echo "MCP test passed!"
              cat test-response.json
              break
            else
              echo "MCP test attempt $i failed, retrying..."
              sleep 10
            fi
          done
          
          # Clean up
          rm -f test-mcp-payload.json test-response.json health-response.json